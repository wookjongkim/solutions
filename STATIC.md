## STATIC (코드 정적 검증 도구)
- 정적 분석 시간 단축
- 쉽고 빠른 결함 수정 및 관리(수정 가이드 제공 및 결함 필터를 사용한 빠른 검색, 결함 진행 상황 추적을 통한 관리)
- 프로젝트 관리의 용이성(프로젝트 관리자와 실무자의 관심 영역 구분한 오버뷰)
- Fix Reference 기능(사용자 추천 시스템에 의한 수정 이력 추천, 쉽게 결함 수정하도록 가이드)

### Runtime Error 중 검출 가능한 것

#### 1. 산술오류
-> 어떤 연산의 결과 값이 자료형의 한계를 넘어설 때<br>

(C 예시)<br>
int 범위 -> -2147483648 ~ 2147483647

```c
int main(void){
  int num = 2147483647 + 2147483647
  printf("%d\n", num); // 여기서 int overflow 발생
}
```
#### 2. 메모리 오류
-> ex) 잘못된 메모리 접근, 메모리 누수 및 잘못된 메모리 해제<br><br>

Memory Leak이란?<br>
`할당된 메모리를 사용한 다음 반환하지 않는 것이 누적되어 프로그램이 필요하지 않는 메모리를 계속 점유하고 있는 현상`<br>

<br><br>
코드 예시<br>

```c
char *a = malloc(20);    // 포인터 변수 a에 동적 메모리 할당
char *b = malloc(10);    // 포인터 변수 b에 동적 메모리 할당

b = a;    // b가 가지고 있던 주소값을 a에 할당

free(a);  // 포인터 a에 할당한 20바이트의 메모리를 해제
free(b);  // 포인터 b에 할당한 10바이트의 메모리가 아닌 a에 할당한 20바이트 메모리 해제

// 포인터 b에 할당했던 10바이트 메모리가 할당 해제 될 수 없는 상태가 됨(memory leak 발생)
```

#### 3. 배열 경계 오류
-> 보안 취약점 관련 오류나 buffer overflow<br>

buffer overflow란?<br>
`연속된 메모리 공간을 사용하는 프로그램에서 할당된 메모리의 범위를 넘어선 위치에 자료를 읽거나 쓰려고 할 때 발생하는 것`<br>

---

### 코딩 규칙 검사

각 도메인별로 준수해야 하는 코딩 규칙을 자동으로 검사해줌

![image](https://github.com/wookjongkim/solutions/assets/121083077/91f7aa42-cbaa-40e7-8e87-bf877e20bc10)

#### MISRA란?<br>

자동차 내장형 시스템 SW는 코드 라인수가 100만줄이 넘어갈 정도로 복잡도가 증가 -> 이에 따른 버그의 발생 확률을 높이며, 이런 버그는 생명과도 직결되어 있음<br>
-> 이 상황에서 등장한 것이 MISRA
-> `임베디드 시스템 소프트웨어에 대한 안전, 보안, 신뢰성을 보장하는 코딩 가이드 라인 정도로 이해`

---

### 사이버 보안 코딩 규칙
eS95489-23 100% 대응<br>
-> 4종 룰셋 제공을 통해 상세한 결함 정보 파악이 가능(C와 C++에 대해서는 98프로, 자바는 현재 35프로 향후 사업 일정에 따라 지원 예정)<br>
<br>

`ES95489-23` : 현대자동차에서 차량용 임베디드 소프트웨어의 신뢰성과 보안성 향상을 위해 만든 보안코딩 기준 사양서

---

### SW 품질 메트릭
다양한 SW 품질 메트릭 측정 지원<br>
-> `다양한 단위(모듈, 파일, 클래스, 함수)의 SW 품질 메트릭 (약 30종) 제공` <br>
-> 품질 메트릭이란 SW의 품질을 정량화 하기 위한 지표 정도로 이해<br>
-> 함수 메트릭 6종 지원, C의 경우 25종, Java/C#의 경우 10종 지원<br>

---

### 분산 컴퓨팅을 활용한 빠른 분석
여러 pc를 자원으로 활용하여 분석에 드는 시간과 비용을 분산, 약 300개 C++ 소스파일 1분 이내 분석 가능하며 별도 APU 서버 확보 필요

---

## ISO-26262가 뭐지?
`자동차에 탑재 되는 전기전자(E/E) 시스템의 오류로 인한 사고를 방지하기 위해 ISO에서 제정한 자동차 기능 안전 국제 규격`<br><br>

총 10개의 파트와 43개의 요구사항 및 권고사항으로 구성되어 있으며, 개발 초기부터 생산 ~ 폐기까지 이르는 소프트웨어 전체 생명주기(SDLC)에서의 안전 관련 요구사항을 제시하고 있음<br>
-> `이 중, Part 6은 소프트웨어 수준의 제품 개발을 위한 규격`

### ISO 26262의 소프트웨어 검증 단계
1. Verfication of software unit design(ISO 26262-6-8)
2. Software unit Testing(ISO 26262-6-9)
3. Software integration and Testing(ISO 26262-6-10)
4. Verification of software safety requirements(ISO 26262-6-11)

#### 1. Verification of software unit design(소프트웨어 단위 설계 및 구현 검증)

![image](https://github.com/wookjongkim/solutions/assets/121083077/98c72c4e-cead-465f-942f-c6475ce1c4f1)

- 워크쓰루 : 개별 멤버가 집단 토의에 따라 설계 문서나 프로그램 중의 논리적인 오류를 발견하는 방법
- 인스팩션 : 이상점을 감지하기 위하여 공식 절차에 따른 작업 산출물의 조사
- 준정형 검증
- 정형 검증 : 명세 된 것에 대해 소프트웨어의 정확성을 증명하기 위해 사용하는 기법
- 제어 흐름 분석 : 소프트웨어 흐름을 그래프로 표현하여 분석하는 기법
- `정적 코드 분석` : 실제 실행 없이 코드를 분석하는 것이며, MISRA(Motor Industry Software Reliability Association)에서 개발된 C 프로그래밍에 대한 개발 표준을 이용한 검증
- `의미적 코드 분석` : 문장의 의미를 근거로 실제 소스코드의 문장을 해석하여 오류를 검출하는 방법. Ex) RunTime Error, Divide by Zero, NPE 등

#### 2. Software unit Testing(소프트웨어 단위 시험)

![image](https://github.com/wookjongkim/solutions/assets/121083077/c02e71c6-cb8b-449b-9436-a55bb9e04b56)

단위 시험은 소프트웨어 소스 코드의 단위(보통 메서드)가 의도된 대로 작동하는지 검증하는 절차<br>

- 요구 사항 기반 시험 : 소프트웨어 각 단위가 요구사항에 기반하여 설계/동작하는지 시험
- 인터페이스 시험 : 소프트웨어의 각 단위의 인터페이스를 시험
- 결함 주입 시험 : 소프트웨어 각 단위에 인위적으로 결함을 주입하여 오류를 파악하고 기능 안전성을 시험
- 자원 사용 시험 : 소프트웨어가 이식되는 대상 하드웨어 또는 자원 사용 시험을 지원하는 에뮬레이터에서 소프트웨어 실행 시 stack overflow등을 검출하는 시험방법
- 모델과 코드 간 비교 시험 : 모델과 Auto Code, 모델과 Manual Code 간 일치성을 검증하는 방법

![image](https://github.com/wookjongkim/solutions/assets/121083077/31b46726-d2e6-4094-a904-14961bd3dd7e)

- 요구 사항 분석 : 소프트웨어 사양서를 바탕으로 시험 케이스 생성
- 동치 클래스의 생성 및 분석 : 동등 클래스 분할이라고도 하며, 시스템에서 요구하는 입력데이터를 각 클래스로 분할하고 한 클래스 내의 결함이 발생하면 그 안의 다른 데이터에서도 동일한 결함이 발생한다는 가정 하에 각 클래스마다 대표되는 데이터 값을 선정하여 시험 케이스를 생성
- 경계값 분석 : 동등분할의 경계부분에 해당되는 입력 값에서 결함이 발견될 확률이 경험적으로 높기 때문에 결함을 방지하기 위해 경계 값까지 포함하여 시험 케이스 생성
- 오류 추측 : 이전에 수행했던 경험과 전문가적인 지식에 기반하여 시험 케이스를 생성

![image](https://github.com/wookjongkim/solutions/assets/121083077/2146e8ba-f367-436f-9328-858c41a54cdd)

- 구문 커버리지 : 코드에서의 구문을 나타내며, 실행 코드라인이 한번 이상 실행되면 충족
- 분기 커버리지 : 각 내부 조건이 true or false를 가지면 충족
- MC/DC(Modified condition/decision coverage) : 분기 내에서 발생할 수 있는 모든 논리적인 조합 중 단위 조건 하나의 값으로 값이 고정된 다른 모든 것을 참 혹은 거짓으로 변경하여 전체 분기의 평가에 영향을 주는 조합

#### 3. Software Integration and Testing(소프트웨어 통합 시험)

![image](https://github.com/wookjongkim/solutions/assets/121083077/1c57d90b-dc3e-472c-88e9-eb9f3bcf61b7)

단위 시험과 전체적인 시험 방법 및 테스트 케이스 생성 방법이 같음<br>
다만, 단위 시험은 소프트웨어 단위가 단위 설계 명세서와 부합한다는 것과 기능성 및 강건성을 증명하기 위한 것이라면, 통합시험은 소프트웨어 아키텍쳐 설계에 대해 소프트웨어 단위 사이의 통합 수준과 인터페이스를 시험하기 위한 것이라는 차이점. 그리고 ASIL C 등급의 경우 결함 주입 시험(FIT)에서 권장 사항에 차이가 있습니다.<br>

![image](https://github.com/wookjongkim/solutions/assets/121083077/39a6acd6-0714-4d38-8977-8492d7e3b76f)

- 함수 커버리지 : 도출된 통합 시험 케이스를 실행했을 때, 전체 소프트웨어 함수 대비 실행된 함수의 비율
- 호출 커버리지 : 소프트웨어 함수 호출이 어느 정도 실행되었는지를 나타난 비율

#### 4. Verification of software safety requirements(소프트웨어 안전 요구사항 검증)

소프트웨어가 소프트웨어 안전 요구사항을 충족하는지 증명하는 절차<br>

![image](https://github.com/wookjongkim/solutions/assets/121083077/0a12d8d8-89b5-4c3f-9dac-4222443e963d)

슈어소프트테크에는 ISO 26262에서 제시하는 소프트웨어 수준의 검증에 대해 각 단계별로 설계부터 실행까지의 프로세스를 손쉽게 할 수 있는 검증 자동화 도구와 3자 검증 서비스가 있습니다.<br>

![image](https://github.com/wookjongkim/solutions/assets/121083077/d18e1940-3440-401a-8052-fc556587fdec)


### 등장 배경

![image](https://github.com/wookjongkim/solutions/assets/121083077/9df932e6-6959-4617-ae53-4be877423d70)

자동차 산업 전반의 복잡성이 중가하면서, 안전성 관련 표준이 주목을 받기 시작

#### ASIL(Automotive Safety Integrity Level)이란?
`ISO 26262 준수를 위한 핵심 사항`으로서, A~D등급으로 나뉨. D등급으로 갈수록 안전이 중요한 프로세스 라는 뜻(ex: d등급의 경우 조향, 브레이크 등등)<br>
-> 각 방법의 경우 해당 방법을 사용하기 위한 권장사항은 ASIL에 따름<br>

- "++"는 해당 방법이 식별된 ASIL에 대해 매우 권장
- "+"는 해당 방법이 식별된 ASIL에 대해 권장
- "O"는 해당 방법이 식별된 ASIL에 대해 권장사항이 없음


#### ADAS(Advanced Driver Assistance System)
`운전자가 안전하고 편리하게 주행할 수 있도록 도와주는 모든 기능`, 자율 주행 관련 기능으로 봐도 됨

- 전방 충돌방지 보조(FCA)
- 차량 이탈방지 보조(LKA : Lane Keeping Assist)
- 후측방 충돌방지 보조(BCA : Blind-Spot Collision-Avoidance Assist)
- 안전 하차 보조(SEA : Safety Exit Assist)

#### By-wire Systems
물리적 연결 대신 전기 신호를 통해서 다양한 기능을 수행하는 것

#### Active Systems
차량의 안전성과 성능을 향상시키기 위한 시스템. ex) 액티브 서스펜션, 액티브 스티어링
-> 더 나은 핸들링,안정성 등등

#### ESC(Electronice Stability Control : 전자식 안정성 제어 시스템)
차량의 미끄러짐을 방지하고 방향 제어 능력을 유지할 수 있도록 돕는 기술

---
### 코드 커버리지

코드 커버리지란, 테스트 수행 결과를 정량적인 수치로 나타내는 방법입니다.<br>
소프트웨어를 이루는 소스 코드(테스트 대상) 중 테스트를 통해 실행된 코드의 비율을 뜻합니다.<br>
<br>
소스 코드를 구분할때는 크게 `구문(Statement)`, `조건(Condition)`, `결정(Decision)`을 요소로 합니다.<br>
-> 간단히 설명하자면 구문은 Line과 비슷, 조건은 x < 0과 같은 조건식, 결정은 조건으로 인해 나올 수 있는 결과 값입니다.<br>
<br>

```java
int x = 3; // 1
int y = 0; // 2
y = x + 3; // 3
if(y < 5){ // 4
   x = 5;  // 5
}          // 6
else{      // 7
   x = 10; // 8
}          // 9
y = 0;     // 10
```

위의 코드를 예시로 하였을때 구문의 숫자는 분기를 제외한 `6개`, 조건은 line 4의 조건 "y < 5"의 참과 거짓 총 `2개`, 결정은 line 4의 결과 참과 거짓, `2개`입니다.<br>
<br>
10라인 중에서 else 라인이 실행 되지 않았다면 구문 커버리지는 `(1개 조건(참) 수행) / (2개 조건 대상) * 100 = 83.33%` <br>
<br>
조건 커버리지는 조건에 대한 참 또는 거짓이 수행 되면 커버되었다고 함<br>
예를들어 10 라인 중 else 구문이 수행되지 않았다면 커버리지는 50%( (1개 조건(참) 수행) / (2개 조건 대상) * 100)가 됩니다<br>
<br>
결정 커버리지는 각 분기의 결과에 대한 참 또는 거짓이 수행되면 커버되었다고 함<br>
예를들어 10라인 중 else 구문이 수행되지 않았다면 커버리지는 50%가 됨<br>
<br>
조건과 결정을 복합적으로 고려하는 MC/DC 커버리지도 존재!<br>

---

### 예상 질문

<details markdown = "1">
<summary>(CodeScroll) STATIC에 대해 설명해봐라</summary>
STATIC은 저희 슈어소프트테크에서 제공하고 있는 코드 정적 검증 도구 입니다.<br>
스태틱의 경우 우선 도메인 별로 준수해야 하는 코딩 룰을 자동으로 검사 해준다는 장점을 가지고 있습니다.<br>
자동차 분야에서는 MISRA(미즈라), ISO 26262, ES 95489-23, 항공 분야에서는 DO-178, 국방의 경우 DAPA(다파), 전기/전자의 경우 IEC61508과 같이 각 도메인에 특화된 표준에 대해 현재 소스코드가 이를 잘 지키고 있는지 확인할 수 있습니다. 만약 표준에 대한 위배 사항들이 나오게 될 시, 관련 수정을 용이하게 진행하실 수 있도록 결함 필터를 통한 검색, 결함 진행 상황 추적, 수정 관련 가이드를 제공하는 Fix Reference 기능을 제공하고 있습니다.<br>
또한 실행 과정을 거치지 않고도 스태틱을 사용할 시 RuntimeError 중 산술 오류, 메모리 누수와 같은 메모리 오류, 버퍼 오버플로우와 같은 배열 경계 오류를 검출할 수 있습니다.<br>
그리고 모듈, 클래스, 메서드 등 다양한 단위에 대한 SW 품질 메트릭 측정을 지원해 드리고, 사이버 보안 큐딩 규칙에 대한 룰도 제공해 드리고 있습니다.<br>
특히 자동차 도메인에 한정해서 본다면 현대 자동차의 보안 관련 표준인 ES95489-23에 100퍼센트 대응할 수 있으며, 4종 룰셋 제공을 통해 상세한 결함 정보 또한 파악할 수 있습니다.<br>
<br>
지원 언어(C, C++, C#, JAVA)를 지원, Named User 3 유저 제공, 웹 기반 UI를 제공한다는 내용도 추가하면 좋을 듯<br>
</details>

<details markdown = "1">
<summary>정적 분석과 동적 분석의 차이에 대해 아는가??</summary>
정적 분석(검증)은 소스코드를 실행하지 않고 분석하는 과정입니다. 코드의 복잡도, 표준 준수 여부나 타입 체크 등을 검사합니다.(구조적 결함 찾음)<br>
동적 검증은 모델을 실제로 실행하여 검사하는 과정입니다. 테스트 케이스를 실행하여 예상된 결과를 실제 결과와 비교하고, 런타임 오류나 성능 등 실행 중에 발견할 수 있는 문제들을 검사합니다.
</details>

<details markdown = "1">
<summary>정적 분석이 왜 중요하냐?</summary>
완성되지 않은 코드에 대해서도 분석이 가능하기 때문에 동적 테스트보다 이른 시점, 그리고 적은 비용으로 버그를 찾아낼 수 있기 때문입니다.<br>
예를들어 개발 단계에서는 비교적 짧은 동적 테스트를 통해 결과를 신속하게 확인해야 하는 경우가 많기에, 이 과정에서 memory leak과 같은 문제는 감지하기 어렵습니다.<br>
하지만 정적 분석을 진행한다면, 코드를 실행하지 않고도 이러한 문제를 초기에 발견함으로서 추후 고 비용이 들 수 있는 버그 수정 과정을 예방할 수 있습니다.<br>
</details>

<details markdown = "1">
<summary>동적 분석이 왜 중요하냐?</summary>
실제 실행을 진행하기에, 정적 분석만으로는 감지할 수 없는 런타임 문제나 예외 상황을 발견할 수 있습니다.
</details>

<details markdown = "1">
<summary>(테스트 or 코드) 커버리지가 무엇인지?</summary>
소프트웨어를 이루고 있는 소스 코드(테스트 대상) 중 테스트를 통해 실행된 코드의 비율을 뜻합니다<br>
커버리지 종류에는 구문, 조건, 결과, mc/dc 등이 있습니다<br>

`구문 커버리지`는 소프트웨어의 모든 실행 가능한 문장이 테스트 중에 적어도 한번은 실행되었는지 나타내는 지표입니다.<br>
`조건 커버리지`는 조건식에 대한 참 또는 거짓이 수행되었는지 나타내는 지표이고, 결정 커버리지는 각 분기의 결과에 대한 참 또는 거짓이 수행되었는지 나타내는 지표입니다.<br>
`MC/DC(Modified Condition : 개별 조건식 / Decision : 전체 조건식 Coverage) 커버리지`는 각 조건이 전체 조건문(분기)의 결과에 어떻게 영향을 미치는지를 확인하는 지표입니다.<br>
-> 테스트케이스 조합의 개수를 줄이면서, 개별 조건식까지 테스트를 수행하기 위해 고안된 기법<br>
</details>

---

### 관련 설명 대본
저희가 오늘 소개드릴 static이나 ct같은 경우에는 보통 로우 레벨에서 테스트하는 도구라고 보면 될 것 같습니다.<br><br>
이 테스트를 진행하실 때에는 보통 코드가 구현된 상태에서 가장 로우 레벨에서 진행하시는게 소프트웨어 정적분석과 동적 분석이라고 보시면 될 것 같습니다.<br><br>
최근에 이런 테스트 시장에서는 가장 기본이 되는 테스트라고 보시면 될 것 같습니다. 그래서 저희 도구로 이런 부분들을 해결할 수 있도록 도움을 드리고 있고요.나머지 저희가 차량 쪽에서 특화된 도구들을 많이 가지고 있어요. 그래서 뭐 블랙박스 테스팅을 자동화할 수 있는 화면 기반 시험 도구라던지, 뭐 데이터 관리 솔루션, 결합 주입 솔루션 이런 것을 가지고 있습니다. <br><br>

요청 주셨던 코드 정적 검증 솔루션 스태틱이라는 제품입니다.<br> <br>
현재 저희가 자동차 항공 보안 국방 이런 쪽에 있는 표준 룰들을 보유하고 있고요. 지금 말씀하신 전기 전자, iec 61508 같은 경우도 보유를 하고 있어서 펑셔널 세이프티를 대응을 하실 때 이 스태틱 도구에서 이 iec 61508 룰을 실제로 수행 하셔서 여기서 위배되는 사항들을 검출을 하셔서 수행하시는 이런 역할이라고 보시면 될 것 같습니다.<br><br>
정적 검증 같은 경우에는 사실 툴만 보유하고 있으면, 수행하는 것은 굉장히 단순합니다. <br><br>
툴에서 코드를 한번 수행을 해서 이 iec 61508에서 검출된 위배 사항들이 나오게 되면 개발자가 이 위배된 사항들을 보고나서 아, 저희 툴에서 또 그럼 위배가 왜 일어났는지를 설명해줍니다.<br><br>
툴 내에서, 그래서 보시고 나서 아, 이래서 지금 현재 여기서 위배가 되었구나, 이렇게 수정하세요. 이런 굿 케이스를 드리고 있어서, 보시고 나서 수정을 하시면 되는 그런 단순한 기능이라고 보면 될 것 같습니다. <br><br>
이 이외에도 저희가 뭐 사이버 보안 코딩 규칙에 대한 룰도 저희가 정립을 하고 있어서 이런 부분들은 저희 툴을 구매하시게 되면 모두 다 제공을 드리고 있습니다. <br><br>
그리고 저희 툴에서 이런 주요 기능 코딩 규칙뿐만 아니라 소프트웨어 품질 메트릭도 제공을 드리고, 정적 분석을 할 때 코딩 규칙에 대한 규약을 다 검출해서 수정했는지도 보고 함수에 코드들의 메트릭, 복잡도라든지 함수의 메트릭스가 잘 최적화가 되었는지도 또 판단을 합니다. <br><br>
이런 부분들은 저희 툴에서 또 제공을 드리고 있어서, 정적 분석을 할 때 메트릭도 함께 측정할 수 있도록 제공 드리고 있습니다. 저희 도구 같은 경우는 웹 기반으로 제공을 드리고 있어서 분산 컴퓨팅 이라는 기능을 가지고 있습니다. <br><br>
소위 말해서 토렌트 라는 다운로드 방식을 아신다면, 사용자가 많아질수록 분석 속도가 빨라지는 cpu를 나눠서 같이 사용해서 분석 속도를 높이는 방식을 채택해서 쓰고 있어서, 사용자가 많을수록 퍼포먼스가 늘어나는 이런 기능을 가지고 있습니다.<br><br>
그리고 저희 툴의 ui 같은 경우에는 관리자 영역하고 실무자 영역, 이렇게 나눠서 보여드리고 있습니다. 관리자 영역 같은 경우에는 프로젝트 오버뷰를 보여드리고 있고요. <br><br>
파일의 개수라던지, 펑션의 개수라던지, 추이 이런 것을 그래프랑 숫자화해서 보여드리고 있습니다. 실무자같은 경우에는 실제로 결함이 검출된 부분을 보시게 되면, 지금 현재 어느 부분이 결함이 생겼고, 이런 케이스로 인해서 결함이 발생했다~~ 이런 식으로 변경해야한다고 보여드리고 있습니다.<br><br>
앞 서 말씀드렸던 부분이랑 같은 부분인데요. 이렇게 수정 가이드를 제공하고 있고, 웹 기반으로 네임드 유저 기반으로 제공을 드리고 있어서, 이 툴을 사용하시게 되면 기본적으로 계정들을 생성하고 제공 드리고 있습니다. 각 계정마다 상호간의 추적 관리를 할 수 있도록 대시보드를 제공 드리고 있습니다. <br><br>
그래서 실제로 팀장 역할을 부여받은 계정을 가지고 그 팀원 분들께 업무를 지시를 하던지, 어싸인을 하고, 그리고 지시받은 팀원들이 이 부분은 수정했다 다시 한번 어싸인 하고, 이런 식의 이슈 관리를 할 수 있도록 저희 도구 내에서 이런 대시 보드를 제공 드리고 있습니다. <br><br>
관리자 페이지도 이렇게 결함 추이 정보를 선형 그래프 원형 그래프 이렇게 다 보여드리고 있어서 한눈에 보기 쉽게 제공 드리고 있습니다. 그리고 프로젝트 관리자가 실제로 팀원 분들에게 이 목표기능을 설정화 기능을 해서 현재 어떤 날짜까지 이런 부분에 대한 코딩 규칙을 수정해주세요 이런 타임 리미트라던지 사이클을 관리할 수 있도록 툴 내에서 제공 드리고 있습니다.<br><br>
이것도 같은 내용이라고 보면 될 것 같고요. 그리고 정적 분석 도구 같은 경우에는 저희뿐만 아니라 타 도구 같은 경우에도 유사한 기능을 보유하고 있습니다. <br><br>
다만 이것은 저희 회사에서만 제공을 드리는 부분인데, 픽스 레퍼런스라고 해서, 지금 이런 사내의 수정하시는 개발자 분들이던지 테스트 분들이 계시면 본인이 수정한 내역들을 이력관리를 해서 pt 레퍼런스에 집어넣을 수 있습니다.<br><br>
그럼 사내 모든 테스트나 개발자 분들께서 이런 비슷한 유형의 이런 결함이 검출되었을 때 이분은 이렇게 수정을 했네, 이런 케이스를 공유할 수 있도록 저희 도구 내에서 제공을 하고 있습니다. <br><br>
저희 한화 큐셀 뿐만 아니라 타 업체가 우리가 이렇게 수정을 했는데 좀 효과적인 것 같다고 여기에 올려도 괜찮겠다고 타 업체가 레퍼런스 창에다가 상호간에 교류를 할 수 있도록 제공을 드리고 있습니다. 원하시지 않으면 안하셔도 됩니다. <br><br>
네 그리고 레거시 코드가 많은 경우에는 베이스라인을 그려서 여기 아래까지는 레거시 코드여서 우리가 그리고 손대지 않았던 코드이기 때문에 이 부분은 저희가 정적 검증 대상에서 제외를 한다. 이런 기능들을 또 가지고 있고요. <br><br>
또 메트릭스 같은 경우에는 이런 식으로 수치화해서 보여드리고 있습니다. 저희 도구 같은 경우에는 현재 c c++ java c# jsp까지 제공을 드리고 있고요. 컴파일러같은 경우에는 지금 어떤 개발 환경을 사용하는지는 모르겠지만 보통 저희가 도구를 구매하시고 나면, 저희가 이런 개발 환경이 변경되거나 개발 환경이 신규로 추가되거나 했을 때 이런 부분의 셋팅은 저희가 별도로 다 지원 드리고 있습니다. 나머지 이런 레퍼런스 같은 경우에는 보시고 나서 궁금하신 점 있으시면 저희에게 질문 주시면 답변 드리도록 하겠습니다.  
<br><br>







