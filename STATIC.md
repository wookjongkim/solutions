## STATIC (코드 정적 검증 도구)
- 정적 분석 시간 단축
- 쉽고 빠른 결함 수정 및 관리(수정 가이드 제공 및 결함 필터를 사용한 빠른 검색, 결함 진행 상황 추적을 통한 관리)
- 프로젝트 관리의 용이성(프로젝트 관리자와 실무자의 관심 영역 구분한 오버뷰)
- Fix Reference 기능(사용자 추천 시스템에 의한 수정 이력 추천, 쉽게 결함 수정하도록 가이드)

### Runtime Error 중 검출 가능한 것

#### 1. 산술오류
-> 어떤 연산의 결과 값이 자료형의 한계를 넘어설 때<br>

(C 예시)<br>
int 범위 -> -2147483648 ~ 2147483647

```c
int main(void){
  int num = 2147483647 + 2147483647
  printf("%d\n", num); // 여기서 int overflow 발생
}
```
#### 2. 메모리 오류
-> ex) 잘못된 메모리 접근, 메모리 누수 및 잘못된 메모리 해제<br><br>

Memory Leak이란?<br>
`할당된 메모리를 사용한 다음 반환하지 않는 것이 누적되어 프로그램이 필요하지 않는 메모리를 계속 점유하고 있는 현상`<br>

<br><br>
코드 예시<br>

```c
char *a = malloc(20);    // 포인터 변수 a에 동적 메모리 할당
char *b = malloc(10);    // 포인터 변수 b에 동적 메모리 할당

b = a;    // b가 가지고 있던 주소값을 a에 할당

free(a);  // 포인터 a에 할당한 20바이트의 메모리를 해제
free(b);  // 포인터 b에 할당한 10바이트의 메모리가 아닌 a에 할당한 20바이트 메모리 해제

// 포인터 b에 할당했던 10바이트 메모리가 할당 해제 될 수 없는 상태가 됨(memory leak 발생)
```

#### 3. 배열 경계 오류
-> 보안 취약점 관련 오류나 buffer overflow<br>

buffer overflow란?<br>
`연속된 메모리 공간을 사용하는 프로그램에서 할당된 메모리의 범위를 넘어선 위치에 자료를 읽거나 쓰려고 할 때 발생하는 것`<br>

---

### 코딩 규칙 검사

각 도메인별로 준수해야 하는 코딩 규칙을 자동으로 검사해줌

![image](https://github.com/wookjongkim/solutions/assets/121083077/91f7aa42-cbaa-40e7-8e87-bf877e20bc10)

#### MISRA란?<br>

자동차 내장형 시스템 SW는 코드 라인수가 100만줄이 넘어갈 정도로 복잡도가 증가 -> 이에 따른 버그의 발생 확률을 높이며, 이런 버그는 생명과도 직결되어 있음<br>
-> 이 상황에서 등장한 것이 MISRA
-> `임베디드 시스템 소프트웨어에 대한 안전, 보안, 신뢰성을 보장하는 코딩 가이드 라인 정도로 이해`

---

### 사이버 보안 코딩 규칙
eS95489-23 100% 대응<br>
-> 4종 룰셋 제공을 통해 상세한 결함 정보 파악이 가능(C와 C++에 대해서는 98프로, 자바는 현재 35프로 향후 사업 일정에 따라 지원 예정)<br>
<br>

`ES95489-23` : 현대자동차에서 차량용 임베디드 소프트웨어의 신뢰성과 보안성 향상을 위해 만든 보안코딩 기준 사양서

---

### SW 품질 메트릭
다양한 SW 품질 메트릭 측정 지원<br>
-> `다양한 단위(모듈, 파일, 클래스, 함수)의 SW 품질 메트릭 (약 30종) 제공` <br>
-> 품질 메트릭이란 SW의 품질을 정량화 하기 위한 지표 정도로 이해<br>
-> 함수 메트릭 6종 지원, C의 경우 25종, Java/C#의 경우 10종 지원<br>

---

### 분산 컴퓨팅을 활용한 빠른 분석
여러 pc를 자원으로 활용하여 분석에 드는 시간과 비용을 분산, 약 300개 C++ 소스파일 1분 이내 분석 가능하며 별도 APU 서버 확보 필요

---

## ISO-26262가 뭐지?
`자동차에 탑재 되는 전기전자(E/E) 시스템의 오류로 인한 사고를 방지하기 위해 ISO에서 제정한 자동차 기능 안전 국제 규격`<br><br>

총 10개의 파트와 43개의 요구사항 및 권고사항으로 구성되어 있으며, 개발 초기부터 생산 ~ 폐기까지 이르는 소프트웨어 전체 생명주기(SDLC)에서의 안전 관련 요구사항을 제시하고 있음<br>
-> `이 중, Part 6은 소프트웨어 수준의 제품 개발을 위한 규격`

### ISO 26262의 소프트웨어 검증 단계
1. Verfication of software unit design(ISO 26262-6-8)
2. Software unit Testing(ISO 26262-6-9)
3. Software integration and Testing(ISO 26262-6-10)
4. Verification of software safety requirements(ISO 26262-6-11)

#### 1. Verification of software unit design(소프트웨어 단위 설계 및 구현 검증)

![image](https://github.com/wookjongkim/solutions/assets/121083077/98c72c4e-cead-465f-942f-c6475ce1c4f1)

- 워크쓰루 : 개별 멤버가 집단 토의에 따라 설계 문서나 프로그램 중의 논리적인 오류를 발견하는 방법
- 인스팩션 : 이상점을 감지하기 위하여 공식 절차에 따른 작업 산출물의 조사
- 준정형 검증
- 정형 검증 : 명세 된 것에 대해 소프트웨어의 정확성을 증명하기 위해 사용하는 기법
- 제어 흐름 분석 : 소프트웨어 흐름을 그래프로 표현하여 분석하는 기법
- `정적 코드 분석` : 실제 실행 없이 코드를 분석하는 것이며, MISRA(Motor Industry Software Reliability Association)에서 개발된 C 프로그래밍에 대한 개발 표준을 이용한 검증
- `의미적 코드 분석` : 문장의 의미를 근거로 실제 소스코드의 문장을 해석하여 오류를 검출하는 방법. Ex) RunTime Error, Divide by Zero, NPE 등

#### 2. Software unit Testing(소프트웨어 단위 시험)

![image](https://github.com/wookjongkim/solutions/assets/121083077/c02e71c6-cb8b-449b-9436-a55bb9e04b56)

단위 시험은 소프트웨어 소스 코드의 단위(보통 메서드)가 의도된 대로 작동하는지 검증하는 절차<br>

- 요구 사항 기반 시험 : 소프트웨어 각 단위가 요구사항에 기반하여 설계/동작하는지 시험
- 인터페이스 시험 : 소프트웨어의 각 단위의 인터페이스를 시험
- 결함 주입 시험 : 소프트웨어 각 단위에 인위적으로 결함을 주입하여 오류를 파악하고 기능 안전성을 시험
- 자원 사용 시험 : 소프트웨어가 이식되는 대상 하드웨어 또는 자원 사용 시험을 지원하는 에뮬레이터에서 소프트웨어 실행 시 stack overflow등을 검출하는 시험방법
- 모델과 코드 간 비교 시험 : 모델과 Auto Code, 모델과 Manual Code 간 일치성을 검증하는 방법

![image](https://github.com/wookjongkim/solutions/assets/121083077/31b46726-d2e6-4094-a904-14961bd3dd7e)

- 요구 사항 분석 : 소프트웨어 사양서를 바탕으로 시험 케이스 생성
- 동치 클래스의 생성 및 분석 : 동등 클래스 분할이라고도 하며, 시스템에서 요구하는 입력데이터를 각 클래스로 분할하고 한 클래스 내의 결함이 발생하면 그 안의 다른 데이터에서도 동일한 결함이 발생한다는 가정 하에 각 클래스마다 대표되는 데이터 값을 선정하여 시험 케이스를 생성
- 경계값 분석 : 동등분할의 경계부분에 해당되는 입력 값에서 결함이 발견될 확률이 경험적으로 높기 때문에 결함을 방지하기 위해 경계 값까지 포함하여 시험 케이스 생성
- 오류 추측 : 이전에 수행했던 경험과 전문가적인 지식에 기반하여 시험 케이스를 생성

![image](https://github.com/wookjongkim/solutions/assets/121083077/2146e8ba-f367-436f-9328-858c41a54cdd)

- 구문 커버리지 : 코드에서의 구문을 나타내며, 실행 코드라인이 한번 이상 실행되면 충족
- 분기 커버리지 : 각 내부 조건이 true or false를 가지면 충족
- MC/DC(Modified condition/decision coverage) : 분기 내에서 발생할 수 있는 모든 논리적인 조합 중 단위 조건 하나의 값으로 값이 고정된 다른 모든 것을 참 혹은 거짓으로 변경하여 전체 분기의 평가에 영향을 주는 조합

#### 3. Software Integration and Testing(소프트웨어 통합 시험)

![image](https://github.com/wookjongkim/solutions/assets/121083077/1c57d90b-dc3e-472c-88e9-eb9f3bcf61b7)

단위 시험과 전체적인 시험 방법 및 테스트 케이스 생성 방법이 같음<br>
다만, 단위 시험은 소프트웨어 단위가 단위 설계 명세서와 부합한다는 것과 기능성 및 강건성을 증명하기 위한 것이라면, 통합시험은 소프트웨어 아키텍쳐 설계에 대해 소프트웨어 단위 사이의 통합 수준과 인터페이스를 시험하기 위한 것이라는 차이점. 그리고 ASIL C 등급의 경우 결함 주입 시험(FIT)에서 권장 사항에 차이가 있습니다.<br>

![image](https://github.com/wookjongkim/solutions/assets/121083077/39a6acd6-0714-4d38-8977-8492d7e3b76f)

- 함수 커버리지 : 도출된 통합 시험 케이스를 실행했을 때, 전체 소프트웨어 함수 대비 실행된 함수의 비율
- 호출 커버리지 : 소프트웨어 함수 호출이 어느 정도 실행되었는지를 나타난 비율

#### 4. Verification of software safety requirements(소프트웨어 안전 요구사항 검증)

소프트웨어가 소프트웨어 안전 요구사항을 충족하는지 증명하는 절차<br>

![image](https://github.com/wookjongkim/solutions/assets/121083077/0a12d8d8-89b5-4c3f-9dac-4222443e963d)

슈어소프트테크에는 ISO 26262에서 제시하는 소프트웨어 수준의 검증에 대해 각 단계별로 설계부터 실행까지의 프로세스를 손쉽게 할 수 있는 검증 자동화 도구와 3자 검증 서비스가 있습니다.<br>

![image](https://github.com/wookjongkim/solutions/assets/121083077/d18e1940-3440-401a-8052-fc556587fdec)


### 등장 배경

![image](https://github.com/wookjongkim/solutions/assets/121083077/9df932e6-6959-4617-ae53-4be877423d70)

자동차 산업 전반의 복잡성이 중가하면서, 안전성 관련 표준이 주목을 받기 시작

#### ASIL(Automotive Safety Integrity Level)이란?
`ISO 26262 준수를 위한 핵심 사항`으로서, A~D등급으로 나뉨. D등급으로 갈수록 안전이 중요한 프로세스 라는 뜻(ex: d등급의 경우 조향, 브레이크 등등)<br>
-> 각 방법의 경우 해당 방법을 사용하기 위한 권장사항은 ASIL에 따름<br>

- "++"는 해당 방법이 식별된 ASIL에 대해 매우 권장
- "+"는 해당 방법이 식별된 ASIL에 대해 권장
- "O"는 해당 방법이 식별된 ASIL에 대해 권장사항이 없음


#### ADAS(Advanced Driver Assistance System)
`운전자가 안전하고 편리하게 주행할 수 있도록 도와주는 모든 기능`, 자율 주행 관련 기능으로 봐도 됨

- 전방 충돌방지 보조(FCA)
- 차량 이탈방지 보조(LKA : Lane Keeping Assist)
- 후측방 충돌방지 보조(BCA : Blind-Spot Collision-Avoidance Assist)
- 안전 하차 보조(SEA : Safety Exit Assist)

#### By-wire Systems
물리적 연결 대신 전기 신호를 통해서 다양한 기능을 수행하는 것

#### Active Systems
차량의 안전성과 성능을 향상시키기 위한 시스템. ex) 액티브 서스펜션, 액티브 스티어링
-> 더 나은 핸들링,안정성 등등

#### ESC(Electronice Stability Control : 전자식 안정성 제어 시스템)
차량의 미끄러짐을 방지하고 방향 제어 능력을 유지할 수 있도록 돕는 기술

---
### 코드 커버리지

코드 커버리지란, 테스트 수행 결과를 정량적인 수치로 나타내는 방법입니다.<br>
소프트웨어를 이루는 소스 코드(테스트 대상) 중 테스트를 통해 실행된 코드의 비율을 뜻합니다.<br>
<br>
소스 코드를 구분할때는 크게 `구문(Statement)`, `조건(Condition)`, `결정(Decision)`을 요소로 합니다.<br>
-> 간단히 설명하자면 구문은 Line과 비슷, 조건은 x < 0과 같은 조건식, 결정은 조건으로 인해 나올 수 있는 결과 값입니다.<br>
<br>

```java
int x = 3; // 1
int y = 0; // 2
y = x + 3; // 3
if(y < 5){ // 4
   x = 5;  // 5
}          // 6
else{      // 7
   x = 10; // 8
}          // 9
y = 0;     // 10
```

위의 코드를 예시로 하였을때 구문의 숫자는 분기를 제외한 `6개`, 조건은 line 4의 조건 "y < 5"의 참과 거짓 총 `2개`, 결정은 line 4의 결과 참과 거짓, `2개`입니다.<br>
<br>
10라인 중에서 else 라인이 실행 되지 않았다면 구문 커버리지는 `(1개 조건(참) 수행) / (2개 조건 대상) * 100 = 83.33%` <br>
<br>
조건 커버리지는 조건에 대한 참 또는 거짓이 수행 되면 커버되었다고 함<br>
예를들어 10 라인 중 else 구문이 수행되지 않았다면 커버리지는 50%( (1개 조건(참) 수행) / (2개 조건 대상) * 100)가 됩니다<br>
<br>
결정 커버리지는 각 분기의 결과에 대한 참 또는 거짓이 수행되면 커버되었다고 함<br>
예를들어 10라인 중 else 구문이 수행되지 않았다면 커버리지는 50%가 됨<br>
<br>
조건과 결정을 복합적으로 고려하는 MC/DC 커버리지도 존재!<br>

---

### 예상 질문

<details markdown = "1">
<summary>(CodeScroll) STATIC에 대해 설명해봐라</summary>

</details>

<details markdown = "1">
<summary>정적 분석과 동적 분석의 차이에 대해 아는가??</summary>
정적 분석(검증)은 소스코드를 실행하지 않고 분석하는 과정입니다. 코드의 복잡도, 표준 준수 여부나 타입 체크 등을 검사합니다.(구조적 결함 찾음)<br>
동적 검증은 모델을 실제로 실행하여 검사하는 과정입니다. 테스트 케이스를 실행하여 예상된 결과를 실제 결과와 비교하고, 런타임 오류나 성능 등 실행 중에 발견할 수 있는 문제들을 검사합니다.
</details>

<details markdown = "1">
<summary>정적 분석이 왜 중요하냐?</summary>
완성되지 않은 코드에 대해서도 분석이 가능하기 때문에 동적 테스트보다 이른 시점, 그리고 적은 비용으로 버그를 찾아낼 수 있기 때문입니다.<br>
예를들어 개발 단계에서는 비교적 짧은 동적 테스트를 통해 결과를 신속하게 확인해야 하는 경우가 많기에, 이 과정에서 memory leak과 같은 문제는 감지하기 어렵습니다.<br>
하지만 정적 분석을 진행한다면, 코드를 실행하지 않고도 이러한 문제를 초기에 발견함으로서 추후 고 비용이 들 수 있는 버그 수정 과정을 예방할 수 있습니다.<br>
</details>

<details markdown = "1">
<summary>동적 분석이 왜 중요하냐?</summary>
실제 실행을 진행하기에, 정적 분석만으로는 감지할 수 없는 런타임 문제나 예외 상황을 발견할 수 있습니다.
</details>

<details markdown = "1">
<summary>(테스트 or 코드) 커버리지가 무엇인지?</summary>
소프트웨어를 이루고 있는 소스 코드(테스트 대상) 중 테스트를 통해 실행된 코드의 비율을 뜻합니다<br>
커버리지 종류에는 구문, 조건, 결과, mc/dc 등이 있습니다<br>
구문 커버리지는 소프트웨어의 모든 실행 가능한 문장이 테스트 중에 적어도 한번은 실행되었는지 나타내는 지표입니다.<br>
조건 커버리지는 
</details>
























